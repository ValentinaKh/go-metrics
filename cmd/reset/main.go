package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"golang.org/x/tools/go/packages"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type (
	FieldInfo struct {
		Name string
		Type types.Type
	}

	StructInfo struct {
		PackageName string
		StructName  string
		Fields      []*FieldInfo
	}

	PackageTemplateData struct {
		PackageName string
		Structs     []StructInfo
	}
)

func main() {
	rootDir := "."
	if len(os.Args) > 1 {
		rootDir = os.Args[1]
	}

	fmt.Printf("Scanning for structures with '// generate:reset' comment starting from: %s\n", rootDir)

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo,
		Dir:  rootDir,
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		fmt.Printf("Error loading packages: %v\n", err)
		panic(err)
	}

	packageStructs := make(map[string][]StructInfo)

	for _, pkg := range pkgs {
		if len(pkg.Errors) > 0 {
			for _, e := range pkg.Errors {
				fmt.Printf("Package %s error: %v\n", pkg.PkgPath, e)
			}
			continue
		}

		if strings.Contains(pkg.PkgPath, "reset") {
			continue
		}

		var pkgStructs []StructInfo

		for i, file := range pkg.Syntax {
			filename := pkg.GoFiles[i]

			if strings.HasSuffix(filename, "_test.go") || strings.HasSuffix(filename, ".gen.go") {
				continue
			}

			structs := findResetStructs(file, pkg.TypesInfo, pkg.Name)
			if len(structs) > 0 {
				pkgStructs = append(pkgStructs, structs...)
			}
		}

		if len(pkgStructs) > 0 {
			packageDir := filepath.Dir(pkg.GoFiles[0])
			packageStructs[packageDir] = append(packageStructs[filepath.Join(rootDir, packageDir)], pkgStructs...)
		}
	}

	for pkgDir, structs := range packageStructs {
		if err := generateResetFile(pkgDir, structs); err != nil {
			fmt.Printf("Error generating reset file for package %s: %v\n", pkgDir, err)
		} else {
			fmt.Printf("Generated reset.gen.go for package %s for %d structures\n", pkgDir, len(structs))
		}
	}
}

func findResetStructs(file *ast.File, typeInfo *types.Info, pkgName string) []StructInfo {
	var structs []StructInfo

	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		hasResetComment := false
		if genDecl.Doc != nil {
			for _, comment := range genDecl.Doc.List {
				if strings.HasPrefix(comment.Text, "// generate:reset") {
					hasResetComment = true
					break
				}
			}
		}

		if !hasResetComment {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			var fields []*FieldInfo
			if structType.Fields != nil {
				for _, field := range structType.Fields.List {
					typeI := typeInfo.TypeOf(field.Type)
					for _, name := range field.Names {
						fields = append(fields, &FieldInfo{
							Name: name.Name,
							Type: typeI,
						})
					}
				}
			}

			structs = append(structs, StructInfo{
				PackageName: pkgName,
				StructName:  typeSpec.Name.Name,
				Fields:      fields,
			})
		}
	}

	return structs
}

func generateResetFile(pkgDir string, structs []StructInfo) error {

	tmpl, err := loadTemplates()
	if err != nil {
		return err
	}

	data := PackageTemplateData{
		PackageName: structs[0].PackageName,
		Structs:     structs,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %v", err)
	}

	outputFile := filepath.Join(pkgDir, "reset.gen.go")
	return os.WriteFile(outputFile, formatted, 0644)
}

func loadTemplates() (*template.Template, error) {
	tmpl := template.New("reset").Funcs(template.FuncMap{
		"generateFieldReset": generateFieldReset,
	})

	return tmpl.Parse(`
	// Code generated by reset. DO NOT EDIT.

	package {{.PackageName}}
	
	{{range .Structs}}
	func (c *{{.StructName}}) Reset() {
			if c == nil {
				return
			}
		{{- range .Fields}}
			{{generateFieldReset .}}
		{{- end}}
	}
	{{end}}
`)
}

func generateFieldReset(field *FieldInfo) string {
	fieldAccess := "c" + "." + field.Name
	return generateReset(field, fieldAccess)
}

func generateReset(field *FieldInfo, fieldName string) string {
	typ := field.Type

	if ptr, ok := typ.(*types.Pointer); ok {
		elem := ptr.Elem()
		if _, isStruct := elem.Underlying().(*types.Struct); isStruct {
			return resetForPointerStruct(fieldName)
		}
		return fieldName + " = nil"
	}

	switch t := typ.Underlying().(type) {
	case *types.Struct:
		if named, ok := typ.(*types.Named); ok {
			return resetForStruct(fieldName, named.Obj().Name())
		}
		return fieldName + " = struct{}{}"
	case
		*types.Map:
		return "clear(" + fieldName + ")"
	case *types.Basic:
		switch t.Kind() {
		case types.String:
			return fieldName + ` = ""`
		case types.Bool:
			return fieldName + " = false"
		default:
			return fieldName + " = 0"
		}
	case *types.Array, *types.Slice:
		return fmt.Sprintf("%s = %s[:0]", fieldName, fieldName)
	default:
		return fieldName + " = nil"
	}
}

func resetForPointerStruct(field string) string {
	return fmt.Sprintf(`if resetter, ok := any(%s).(interface{ Reset() }); ok && %s != nil {
       resetter.Reset()
   } else {
		%s = nil
	}`, field, field, field)
}

func resetForStruct(field, t string) string {
	return fmt.Sprintf(`if resetter, ok := any(%s).(interface{ Reset() }); ok {
       resetter.Reset()
   } else {
		%s = %s{}
	}`, field, field, t)
}
